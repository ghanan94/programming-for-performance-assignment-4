\documentclass[12pt]{article}

\usepackage[letterpaper, hmargin=0.75in, vmargin=0.75in]{geometry}
\usepackage{float}
\usepackage{url}


\pagestyle{empty}

\title{ECE 459: Programming for Performance\\Assignment 4}
\author{Ghanan Gowripalan}
\date{\today}

\begin{document}

\maketitle

\section*{Part 1: Performance}

Speed up was obtained when executed with the following parameters:
\begin{table}[H]
  \centering
  \begin{tabular}{lr}
    {\bf Parameter} & {\bf Value} \\
    \hline
    Jobs & 100000 \\
    Policy & 2 \\
    Lamda & 1 \\
    Max Rounds & 2000 \\
    Load Balaning & 0 \\
  \end{tabular}
  \caption{Implementation without speedup}
  \label{tbl-part1-params}
\end{table}

\begin{table}[H]
  \centering
  \begin{tabular}{lr}
    & {\bf 90th percentile} \\
    \hline
    Run 1 & 1.465356 \\
    Run 2 & 1.171047 \\
    Run 3 & 1.599567 \\
    \hline
    Average & 1.411990 \\
  \end{tabular}
  \caption{Implementation without speedup}
  \label{tbl-part1-originall}
\end{table}


\begin{table}[H]
  \centering
  \begin{tabular}{lr}
    & {\bf 90th percentile} \\
    \hline
    Run 1 & 0.216320 \\
    Run 2 & 0.370424 \\
    Run 3 & 0.228262 \\
    \hline
    Average & 0.271669 \\
  \end{tabular}
  \caption{Implementation with speedup}
  \label{tbl-part1-speedup}
\end{table}

Without speedup, an average 90th percentile value of 1.412 was obtained. With the speedup, a 90th percentile of 0.272 was obtained. This resulted in a total speed up of approximately 5.2x.

The speedup was obtained by using mutliple threads for each queue. This would add quite a bit of overhead so the gains must outweigh the losses in performance by adding extra threads. Using the default parameters resulted in the 'spedup' implementation actually performing worse than the original. To have an actual speedup, the lamda value was reduced to 1 (jobs are more frequently generated).



\section*{Part 2: Load Balancing}

\begin{table}[H]
  \centering
  \begin{tabular}{lr}
    {\bf Parameter} & {\bf Value} \\
    \hline
    Jobs & 100000 \\
    Policy & (Depends on test) \\
    Lamda & 1 \\
    Max Rounds & 2000 \\
    Load Balaning & (Depends on test) \\
  \end{tabular}
  \caption{Execution parameters}
  \label{tbl-part2-params}
\end{table}

\begin{table}[H]
  \centering
  \begin{tabular}{lr}
    & {\bf 90th percentile} \\
    \hline
    Run 1 & 0.0 \\
    Run 2 & 0.0 \\
    Run 3 & 0.0 \\
    \hline
    Average & 0.0 \\
  \end{tabular}
  \caption{Implementation without load balancing}
  \label{tbl-part2-originall}
\end{table}

\begin{table}[H]
  \centering
  \begin{tabular}{lr}
    & {\bf 90th percentile} \\
    \hline
    Run 1 & 0.0 \\
    Run 2 & 0.0 \\
    Run 3 & 0.0 \\
    \hline
    Average & 0.0 \\
  \end{tabular}
  \caption{Implementation with load balancing}
  \label{tbl-part2-loadbalance}
\end{table}

Without loadbalancing, an average 90th percentile value of X.XXX was obtained. With the load balancing, a 90th percentile of Y.YYY was obtained. This resulted in a total speed up of approximately Z.Zx.

\paragraph{Data Structure Modifications.} The load balancing was implemented by first modifying the {\tt queue\_t} and {\tt job\_t} data structures.
\begin{description}
  \item [Tail pointer] Originally, the {\tt queue\_t} data structure was a linked list (of {\tt job\_t} nodes) with a pointer to the head of the linked list only. This was the first thing that was modified: a pointer to the tail of the linked list was added to make additions to the linked list faster. With this modification, the runtime to add a new job to the queue was reduced from \( O(n) \) to \( O(1) \) (where \( n \) was the number of jobs currently in the queue.

  \item [Doubly linked list] Originally, the {\tt queue\_t} data structure was a singly linked list (of {\tt job\_t} nodes). This was the next thing to be modified to allow for easy access to nodes that may be closer to the tail than the head of the linked list. To accomdate this, the linked list was modified to a doubly linked list. The modifications were done to the {\tt job\_t} data structure. It originally had only a {\tt next} pointer, but a {\tt prev} pointer was added so that backtracking can occur easily.
\end{description}

\paragraph{Load Balancing Algorithm.} The load balancing was implemented using a dedicated load balancing thread that will (until terminated by setting the {\tt terminate} variable to {\tt 1}) that loops forever doing the following tasks:
\begin{enumerate}
  \item Sleep for 0.2 seconds.
  \item Obtain the locks for each of the queues.
  \item Calcualte average number of rounds of work to be done for all queues.
  \item If average number of rounds of work to be done is greater than maxium allowed rounds per job, then do the load balancing.
  \item Release the locks for each of the queues.
\end{enumerate}

\paragraph{} The load balancing algorithm load balances based on the number of rounds of work that needs to be completed. This is a more accurate representation of how much work each queue has to do compared with just looking at the number of jobs in a queue because different jobs will have varying ammounts of work to do (different service times). The goal is to make each queue have similar (if not identical) ammounts of work to do.

\paragraph{} To load balanace:
\begin{description}
  \item [Remove 'excess' jobs] First 'excess' jobs (jobs that make queues unbalanced relative to the expected average ammount of work to do because they make the queue do too much work), are removed form the queue and added to a seperate list of all 'excess' jobs. After this step,
  \item [Add to 'light' queues] Next, queues that are 'light' (queues where their total ammount of work to do is less than the expected average average ammount of work to do), will have jobs added to them to give them more work to do and balance out the work. The jobs given to these queues are taken from the jobs that were removed form the previous step and added to a list of 'excess' jobs.
\end{description}
\paragraph{} After the load balancing is completed all the queues will have relateively equal ammounts of work with some variance, but the variance after load balancing is a lot less than what it was before the load balancing.

\end{document}
